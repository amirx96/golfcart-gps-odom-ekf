#!/usr/bin/env python

import rospy
import math
import numpy as np
import message_filters
from math import pi
from geometry_msgs.msg import Point, Pose2D, Quaternion, Vector3
from vn300.msg import gps, sensors
from pacmod_msgs.msg import VehicleSpeedRpt, SystemRptFloat
import tf
from nav_msgs.msg import Odometry


# Issues: 
#     Transforms not working
#     Filter blowing up 


class GolfCartEKF:

    def __init__(self):

        rospy.init_node('GolfCartEKF')
        # Parameters
        self.wheelbase = 3.4
        self.rate_IMU  = 50
        self.rate_PCM  = 30
        self.rate_GPS  = 5
        

        # create subscribers
        self.vn300_imu_sub      = rospy.Subscriber('/vectornav/imu',    sensors,    self.predict_step_imu)
        self.vn300_gps_sub      = rospy.Subscriber('/vectornav/gps',    gps,        self.update_step_gps)

        self.pacmod_speed_sub   = message_filters.Subscriber('/pacmod/parsed_tx/vehicle_speed_rpt',     VehicleSpeedRpt)
        self.pacmod_steer_sub   = message_filters.Subscriber('/pacmod/parsed_tx/steer_rpt',             SystemRptFloat)

        ts = message_filters.ApproximateTimeSynchronizer([self.pacmod_speed_sub, self.pacmod_steer_sub], 10, 0.03)
        ts.registerCallback(self.update_step_pacmod)


        self.state_pub = rospy.Publisher('golfcartEKF/state', Odometry, queue_size=10)
        self.state_odom = Odometry()
        self.state_odom.header.frame_id = 'golfcart_frame'
        self.state_odom.child_frame_id = 'world'

        self.br = tf.TransformBroadcaster()

        self.state = np.array([[0.0],[0.0],[0.0],[0.0],[0.0],[0.0]])
        self.state_pacmod = self.state
        self.accel_time = rospy.rostime.Time()
        self.accel_time_init = False
        self.pacmod_time = rospy.rostime.Time()
        self.pacmod_time_init = False
        self.last_gps_time = 0.0
        
        self.lon_home = 0.0
        self.lat_home = 0.0
        self.lon_lat_init = False

        self.Q = np.array([ \
            [1.00, 0.00, 0.00, 0.00, 0.00, 0.00], \
            [0.00, 1.00, 0.00, 0.00, 0.00, 0.00], \
            [0.00, 0.00, 1.00, 0.00, 0.00, 0.00], \
            [0.00, 0.00, 0.00, 1.00, 0.00, 0.00], \
            [0.00, 0.00, 0.00, 0.00, 1.00, 0.00], \
            [0.00, 0.00, 0.00, 0.00, 0.00, 1.00]])

        self.state_cov = self.Q

        self.R_gps = np.array([  \
            [10.0, 00.0], \
            [00.0, 10.0]])
        
        self.R_pcm = np.array([ \
            [1.00, 0.00, 0.00, 0.00, 0.00, 0.00], \
            [0.00, 1.00, 0.00, 0.00, 0.00, 0.00], \
            [0.00, 0.00, 1.00, 0.00, 0.00, 0.00], \
            [0.00, 0.00, 0.00, 1.00, 0.00, 0.00], \
            [0.00, 0.00, 0.00, 0.00, 1.00, 0.00], \
            [0.00, 0.00, 0.00, 0.00, 0.00, 1.00]])


    def predict_step_imu(self, msg):

        if self.accel_time_init:
            dt = msg.header.stamp.to_sec() - self.accel_time.to_sec()
            self.A = np.array([ \
                [1.00, 0.00, 0.00,  dt,  0.00, 0.00 ], \
                [0.00, 1.00, 0.00, 0.00,  dt,  0.00 ], \
                [0.00, 0.00, 1.00, 0.00, 0.00, 0.00 ], \
                [0.00, 0.00, 0.00, 1.00, 0.00, 0.00 ], \
                [0.00, 0.00, 0.00, 0.00, 1.00, 0.00 ], \
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00 ]])

            self.B = np.array([ \
                [ (dt**2)/2*math.cos(self.state[2]), (dt**2)/2*math.sin(self.state[2]), 0.00], \
                [-(dt**2)/2*math.sin(self.state[2]), (dt**2)/2*math.cos(self.state[2]), 0.00], \
                [ 0.00, 0.00, dt], \
                [ dt*math.cos(self.state[2]), dt*math.sin(self.state[2]), 0.00], \
                [-dt*math.sin(self.state[2]), dt*math.cos(self.state[2]), 0.00], \
                [ 0.00, 0.00, 1.00]])

            self.U = np.array([[msg.Accel.x],[msg.Accel.y],[msg.Gyro.z]])
            
            self.state = np.matmul(self.A, self.state) + np.matmul(self.B, self.U)

            # P_k|k-1 = F_k * P_k-1|k-1 * F_k^T + Q_k
            self.state_cov = np.matmul(self.A, np.matmul(self.state_cov, np.transpose(self.A))) + self.Q
        else: 
            self.accel_time_init = True
        
        self.accel_time = msg.header.stamp
        

    def update_step_pacmod(self, speed_msg, steer_msg):
        
        timestamp = (speed_msg.header.stamp.to_sec() + steer_msg.header.stamp.to_sec())/2

        if self.pacmod_time_init:
            dt = timestamp - self.accel_time.to_sec()
            
            self.C = np.array([ \
                [1.00, 0.00, 0.00,  dt,  0.00, 0.00], \
                [0.00, 1.00, 0.00, 0.00,  dt,  0.00], \
                [0.00, 0.00, 1.00, 0.00, 0.00,  dt ], \
                [0.00, 0.00, 0.00, 1.00, 0.00, 0.00], \
                [0.00, 0.00, 0.00, 0.00, 1.00, 0.00], \
                [0.00, 0.00, 0.00, 0.00, 0.00, 1.00]])

            self.X = np.array( [self.state[1], \
                                self.state[2], \
                                self.state[3], \
                                [speed_msg.vehicle_speed*math.cos(self.state[2])], \
                                [speed_msg.vehicle_speed*math.cos(self.state[2])], \
                                [speed_msg.vehicle_speed*math.cos(steer_msg.output*20*math.pi/180)/self.wheelbase]])

            self.H_pcm = np.array([ \
                [1,0,-dt*speed_msg.vehicle_speed*math.sin(self.state[2]),0,0,0], \
                [0,1, dt*speed_msg.vehicle_speed*math.cos(self.state[2]),0,0,0], \
                [0,0,1,0,0,0], \
                [0,0,   -speed_msg.vehicle_speed*math.sin(self.state[2]),0,0,0], \
                [0,0,    speed_msg.vehicle_speed*math.cos(self.state[2]),0,0,0], \
                [0,0,0,0,0,1]])

            # # y_k       = z_k - h(xhat_k|k-1)
            self.y_pcm = np.matmul( self.C, self.X ) - self.state 

            # # S_k       = H_k * P_k|k-1 * H_k^T + R_kError
            self.S_pcm = np.matmul(self.H_pcm, np.matmul(self.state_cov, np.transpose(self.H_pcm))) + self.R_pcm

            # # K_k       = P_k|k-1 * H_k^T * S_k^-1
            self.K_pcm = np.matmul(self.state_cov, np.matmul(self.H_pcm.transpose(), np.linalg.inv(self.S_pcm)))

            # # xhat_k|k  = xhat_k|k-1 + K_k * y_k
            self.state = self.state + np.matmul(self.K_pcm, self.y_pcm)

            # # P_k|k     = (I - K_k * H_k) * P_k|k-1
            self.state_cov = np.matmul((np.eye(6) - np.matmul(self.K_pcm, self.H_pcm)), self.state_cov)


        else: 
            self.pacmod_time_init = True

        self.state_pacmod = self.state
        self.pacmod_time = timestamp
        


    def update_step_gps(self, msg):
        if self.lon_lat_init and not msg.UtcTime.millisecond == self.last_gps_time:
            
            # Ellipsoidal model calculation of Earth
            a = 6378137.0
            b = 6356752.3142
            R = math.sqrt(( math.pow( math.pow(a,2) * math.cos(msg.LLA.x*pi/180), 2)+ \
                            math.pow( math.pow(b,2) * math.sin(msg.LLA.x*pi/180), 2))/ \
                           (math.pow( a * math.cos(msg.LLA.x*pi/180), 2)+ \
                            math.pow( b * math.sin(msg.LLA.x*pi/180), 2))) + msg.LLA.z

            # Transform LLH to 2D position
            dlon = msg.LLA.y - self.lon_home    # degrees
            dlat = msg.LLA.x - self.lat_home    # degrees
            dE = R * math.radians(dlon)     # meters
            dN = R * math.radians(dlat)     # meters

            # # Measurement in matrix format
            measurement = np.array([[dE],[dN]])

            self.H_gps = np.array([  \
                [1.0, 0.0, 0.0, 0.0, 0.0, 0.0], \
                [0.0, 1.0, 0.0, 0.0, 0.0, 0.0]])

            print('\n\nMeasurement')
            print(measurement)
            print('State')
            print(np.matmul(self.H_gps, self.state))

            # # y_k       = z_k - h(xhat_k|k-1)
            self.y_gps = measurement - np.matmul(self.H_gps, self.state)
            
            # # S_k       = H_k * P_k|k-1 * H_k^T + R_kError
            self.S_gps = np.matmul(self.H_gps, np.matmul(self.state_cov, self.H_gps.transpose())) + self.R_gps

            # # K_k       = P_k|k-1 * H_k^T * S_k^-1
            self.K_gps = np.matmul(self.state_cov, np.matmul(np.transpose(self.H_gps), np.linalg.inv(self.S_gps)))
            
            # # xhat_k|k  = xhat_k|k-1 + K_k * y_k
            self.state = self.state + np.matmul(self.K_gps, self.y_gps)
            
            # # P_k|k     = (I - K_k * H_k) * P_k|k-1
            self.state_cov = np.matmul((np.eye(6) - np.matmul(self.K_gps, self.H_gps)), self.state_cov)

            self.last_gps_time = msg.UtcTime.millisecond  

            print('Residual')
            print(self.y_gps)
            print('Residual Cov')
            print(self.S_gps)
            print('Kalman Gain')
            print(self.K_gps)
            print('Update')
            print(np.matmul(self.K_gps, self.y_gps))
            print('Heading')
            print(self.state[2])

        else:
            self.lon_lat_init = True
            self.lat_home = msg.LLA.x
            self.lon_home = msg.LLA.y
        self.state_pacmod = self.state
        self.pacmod_time = msg.header.stamp.to_sec()

    def run(self):

        rate = rospy.Rate(10) # 10 Hz
        while(not rospy.is_shutdown()):
            
            self.state_odom.header.stamp = rospy.Time.now()
            self.state_odom.pose.pose.position = Point(self.state[0],self.state[1],0)
            self.state_odom.pose.pose.orientation = Quaternion(0,0,math.sin(self.state[2]/2),math.cos(self.state[2]/2))
            self.state_odom.pose.covariance = self.state_cov.flatten()
            
            self.state_odom.twist.twist.linear = Vector3(self.state[3],self.state[4],0)
            self.state_odom.twist.twist.angular = Vector3(0,0,self.state[5])
            self.state_odom.twist.covariance = self.state_cov.flatten()

            self.state_pub.publish( self.state_odom )

            self.br.sendTransform(( self.state[0], self.state[1], 0),
                                    tf.transformations.quaternion_from_euler(0, 0, 0),
                                    rospy.Time.now(),
                                    "world",
                                    self.state_odom.header.frame_id)

            rate.sleep()


if __name__ == '__main__':
    GolfCart_EKF = GolfCartEKF()
    GolfCart_EKF.run()