#!/usr/bin/env python

import rospy
import math
import numpy as np
import message_filters
import tf
np.set_printoptions(precision=4)
np.set_printoptions(linewidth=200)

from geometry_msgs.msg  import Point, Pose2D, Quaternion, Vector3, PoseStamped
from pacmod_msgs.msg    import VehicleSpeedRpt, SystemRptFloat
from nav_msgs.msg       import Odometry, Path
from vn300.msg          import ins

class golfcart_ekf:

    def __init__(self):

        rospy.init_node('golfcart_ekf')
        # Parameters
        self.L = 3.4
        self.SR = 22.17144334821909

        # create subscribers
        self.vn300_ins_sub      = rospy.Subscriber('/vectornav/ins', ins, self.update_step_ins)

        self.pacmod_speed_sub   = message_filters.Subscriber('/pacmod/parsed_tx/vehicle_speed_rpt',     VehicleSpeedRpt)
        self.pacmod_steer_sub   = message_filters.Subscriber('/pacmod/parsed_tx/steer_rpt',             SystemRptFloat)

        ts = message_filters.ApproximateTimeSynchronizer([self.pacmod_speed_sub, self.pacmod_steer_sub], 10, 0.03)
        ts.registerCallback(self.update_step_pacmod)

        self.state_pub = rospy.Publisher('golfcart_ekf/combined_state', Odometry, queue_size=10)
        self.path_pub  = rospy.Publisher('golfcart_ekf/combined_path',  Path,     queue_size=10, latch=True)

        self.state_odom = Odometry()
        self.state_odom.header.frame_id = 'golfcart'
        self.state_odom.child_frame_id  = 'world'

        self.br = tf.TransformBroadcaster()
        
        self.ins_time = rospy.rostime.Time()
        self.pacmod_time = rospy.rostime.Time()
        self.pacmod_time_init = False
        
        self.lon_home = 0.0
        self.lat_home = 0.0
        self.lon_lat_init = False

        # Index - Variable- Initial Value:
        #     0 - x       - 0
        #     1 - y       - 0
        #     2 - theta   - 0
        #     3 - vx      - 0
        #     4 - vy      - 0
        #     5 - omega   - 0


        self.state = np.zeros([6,1])
        self.state[2] = -math.pi/2

        self.Q = np.identity(6) 

        self.state_cov = self.Q
        
        self.H_ins = np.zeros([5,6])
        self.H_ins[0,0] = 1.0
        self.H_ins[1,1] = 1.0
        self.H_ins[2,2] = 1.0
        self.H_ins[3,3] = 1.0
        self.H_ins[4,4] = 1.0

        self.H_pcm = np.zeros([3,6])
        self.H_pcm[0,3] = 1.0
        self.H_pcm[1,4] = 1.0
        self.H_pcm[2,5] = 1.0

        self.R_pcm = np.zeros([3,3])
        np.fill_diagonal( self.R_pcm, [0.05, 0.07, 0.01] )

        self.R_gps = np.zeros([3,3])
        np.fill_diagonal( self.R_gps, [0.4, 0.4, 0.75] )

    def update_step_ins(self, msg):
        if not self.lon_lat_init:
            self.lon_lat_init = True
            self.lat_home = msg.LLA.x
            self.lon_home = msg.LLA.y

        else:
            dt = msg.header.stamp.to_sec() - self.ins_time
            F = np.identity(6)
            F[0,3] = dt 
            F[1,4] = dt 
            F[5,5] = 0.0

            self.state = np.matmul(F, self.state)
            
            # P_k|k-1 = F_k * P_k-1|k-1 * F_k^T + Q_k
            self.state_cov = np.matmul(F, np.matmul(self.state_cov, F.T)) + self.Q

            # Ellipsoidal model calculation of Earth
            a = 6378137.0000
            b = 6356752.3142
            R = math.sqrt(( math.pow( math.pow(a,2) * math.cos(msg.LLA.x*math.pi/180), 2)+ \
                            math.pow( math.pow(b,2) * math.sin(msg.LLA.x*math.pi/180), 2))/ \
                           (math.pow( a * math.cos(msg.LLA.x*math.pi/180), 2)+ \
                            math.pow( b * math.sin(msg.LLA.x*math.pi/180), 2))) + msg.LLA.z

            # Transform LLH to 2D position
            dlon = msg.LLA.y - self.lon_home    # degrees
            dlat = msg.LLA.x - self.lat_home    # degrees
            dE = R * math.radians(dlon)         # meters
            dN = R * math.radians(dlat)         # meters
            dT = msg.RPY.z                      # degrees

            R_ins = np.zeros([5,5])
            R_ins[0,0] = msg.PosUncertainty
            R_ins[1,1] = msg.PosUncertainty
            R_ins[2,2] = msg.YawUncertainty
            R_ins[3,3] = msg.VelUncertainty
            R_ins[4,4] = msg.VelUncertainty

            # # Measurement in matrix format
            z = np.array([[dE],[dN],[dT], [msg.NedVel.x], [msg.NedVel.y]])

            # y_k       = z_k - h(xhat_k|k-1)
            y_ins = z - self.state[0:5]

            # # S_k       = H_k * P_k|k-1 * H_k^T + R_kError
            S_ins = np.matmul(self.H_ins, np.matmul(self.state_cov, self.H_ins.T)) + R_ins 

            # # K_k       = P_k|k-1 * H_k^T * S_k^-1
            K_ins = np.matmul(self.state_cov, np.matmul(self.H_ins.T, np.linalg.inv(S_ins)))

            # # xhat_k|k  = xhat_k|k-1 + K_k * y_k
            self.state = self.state + np.matmul(K_ins, y_ins)

            # # P_k|k     = (I - K_k * H_k) * P_k|k-1
            self.state_cov = np.matmul((np.eye(6) - np.matmul(K_ins, self.H_ins)), self.state_cov)

        self.ins_time = msg.header.stamp.to_sec()

    
    def update_step_pacmod(self, speed_msg, steer_msg):
        
        z = np.array([  [speed_msg.vehicle_speed * math.cos(self.state[2])] , \
                        [speed_msg.vehicle_speed * math.sin(self.state[2])] , \
                        [speed_msg.vehicle_speed / self.L * math.tan(steer_msg.output / self.SR) ] ])

        # y_k       = z_k - h(xhat_k|k-1)
        self.y_pcm = z - self.state[3:6]

        # # S_k       = H_k * P_k|k-1 * H_k^T + R_kError
        self.S_pcm = np.matmul(self.H_pcm, np.matmul(self.state_cov, self.H_pcm.T)) + self.R_pcm 

        # # K_k       = P_k|k-1 * H_k^T * S_k^-1
        self.K_pcm = np.matmul(self.state_cov, np.matmul(self.H_pcm.T, np.linalg.inv(self.S_pcm)))

        # # xhat_k|k  = xhat_k|k-1 + K_k * y_k
        self.state = self.state + np.matmul(self.K_pcm, self.y_pcm)

        # # P_k|k     = (I - K_k * H_k) * P_k|k-1
        self.state_cov = np.matmul((np.eye(6) - np.matmul(self.K_pcm, self.H_pcm)), self.state_cov)


    def run(self):

        rate = rospy.Rate(50) # 10 Hz
        while(not rospy.is_shutdown()):
            self.state_odom.header.stamp = rospy.Time.now()
            self.state_odom.pose.pose.position = Point(self.state[0],self.state[1],0)
            self.state_odom.pose.pose.orientation = Quaternion(0, 0, math.sin(self.state[2]/2), math.cos(self.state[2]/2))
            self.state_odom.pose.covariance = self.state_cov[0:6,0:6].flatten()
            
            self.state_odom.twist.twist.linear = Vector3(self.state[3],self.state[4],0)
            self.state_odom.twist.twist.angular = Vector3(0,0,self.state[5])
            self.state_odom.twist.covariance = self.state_cov[0:6,0:6].flatten()

            self.state_pub.publish( self.state_odom )

            self.br.sendTransform(( 0, 0, 0),
                                    tf.transformations.quaternion_from_euler(0, 0, 0),
                                    rospy.Time.now(),
                                    self.state_odom.header.frame_id,
                                    'world')

            rate.sleep()


if __name__ == '__main__':
    GolfCart_EKF = golfcart_ekf()
    GolfCart_EKF.run()
    